<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.tes.batch.scheduler.domain.job.mapper.JobRunLogMapper">

    <!-- Result Map -->
    <resultMap id="JobRunLogResultMap" type="com.tes.batch.scheduler.domain.job.vo.JobRunLogVO">
        <id property="logId" column="log_id"/>
        <result property="jobId" column="job_id"/>
        <result property="jobName" column="job_name"/>
        <result property="systemId" column="system_id"/>
        <result property="systemName" column="system_name"/>
        <result property="groupId" column="group_id"/>
        <result property="groupName" column="group_name"/>
        <result property="celeryTaskName" column="task_id"/>
        <result property="batchType" column="batch_type"/>
        <result property="operation" column="operation"/>
        <result property="status" column="status"/>
        <result property="output" column="output"/>
        <result property="errors" column="error"/>
        <result property="errorNo" column="error_no"/>
        <result property="runDuration" column="duration"/>
        <result property="actualStartDate" column="start_time"/>
        <result property="actualEndDate" column="end_time"/>
        <result property="reqStartDate" column="scheduled_time"/>
        <result property="retryCount" column="retry_attempt"/>
        <result property="workflowRunId" column="workflow_run_id"/>
        <result property="workflowPriority" column="workflow_priority"/>
        <result property="logDate" column="frst_reg_date"/>
        <result property="userName" column="user_name"/>
    </resultMap>

    <!-- Base Column List -->
    <sql id="BaseColumns">
        log_id, job_id, job_name, system_id, system_name, group_id, group_name,
        task_id, batch_type, operation, status, output, error, error_no, duration,
        start_time, end_time, scheduled_time, retry_attempt, workflow_run_id, workflow_priority, frst_reg_date, user_name
    </sql>

    <!-- Find by ID -->
    <select id="findById" resultMap="JobRunLogResultMap">
        SELECT <include refid="BaseColumns"/>
        FROM scheduler_job_run_logs
        WHERE log_id = #{logId}
    </select>

    <!-- Find by Job ID -->
    <select id="findByJobId" resultMap="JobRunLogResultMap">
        SELECT <include refid="BaseColumns"/>
        FROM scheduler_job_run_logs
        WHERE job_id = #{jobId}
        ORDER BY log_id DESC
    </select>

    <!-- Find Latest by Job ID -->
    <select id="findLatestByJobId" resultMap="JobRunLogResultMap">
        SELECT <include refid="BaseColumns"/>
        FROM scheduler_job_run_logs
        WHERE job_id = #{jobId}
        ORDER BY log_id DESC
        LIMIT 1
    </select>

    <!-- Find by Workflow Run ID -->
    <select id="findByWorkflowRunId" resultMap="JobRunLogResultMap">
        SELECT <include refid="BaseColumns"/>
        FROM scheduler_job_run_logs
        WHERE workflow_run_id = #{workflowRunId}
        ORDER BY workflow_priority ASC, log_id ASC
    </select>

    <!-- Find Logs with Filters -->
    <select id="findByFilters" resultMap="JobRunLogResultMap">
        SELECT <include refid="BaseColumns"/>
        FROM scheduler_job_run_logs
        <where>
            <if test="jobId != null and jobId != ''">
                AND job_id = #{jobId}
            </if>
            <if test="systemId != null and systemId != ''">
                AND system_id = #{systemId}
            </if>
            <if test="groupId != null and groupId != ''">
                AND group_id = #{groupId}
            </if>
            <if test="operation != null and operation != ''">
                AND operation = #{operation}
            </if>
            <if test="status != null and status != ''">
                AND status = #{status}
            </if>
            <if test="reqStartDateFrom != null">
                AND scheduled_time &gt;= #{reqStartDateFrom}
            </if>
            <if test="reqStartDateTo != null">
                AND scheduled_time &lt;= #{reqStartDateTo}
            </if>
        </where>
        ORDER BY log_id DESC
        LIMIT #{limit} OFFSET #{offset}
    </select>

    <!-- Count Logs with Filters -->
    <select id="countByFilters" resultType="long">
        SELECT COUNT(*)
        FROM scheduler_job_run_logs
        <where>
            <if test="jobId != null and jobId != ''">
                AND job_id = #{jobId}
            </if>
            <if test="systemId != null and systemId != ''">
                AND system_id = #{systemId}
            </if>
            <if test="groupId != null and groupId != ''">
                AND group_id = #{groupId}
            </if>
            <if test="operation != null and operation != ''">
                AND operation = #{operation}
            </if>
            <if test="status != null and status != ''">
                AND status = #{status}
            </if>
            <if test="reqStartDateFrom != null">
                AND scheduled_time &gt;= #{reqStartDateFrom}
            </if>
            <if test="reqStartDateTo != null">
                AND scheduled_time &lt;= #{reqStartDateTo}
            </if>
        </where>
    </select>

    <!-- Find Logs by Filters and Group IDs - simplified (joins with jobs to filter by group) -->
    <select id="findByFiltersAndGroupIds" resultMap="JobRunLogResultMap">
        SELECT rl.log_id, rl.job_id, rl.job_name, rl.system_id, rl.system_name, rl.group_id, rl.group_name,
               rl.task_id, rl.batch_type, rl.operation, rl.status, rl.output, rl.error, rl.error_no, rl.duration,
               rl.start_time, rl.end_time, rl.scheduled_time, rl.retry_attempt, rl.workflow_run_id, rl.workflow_priority, rl.frst_reg_date, rl.user_name
        FROM scheduler_job_run_logs rl
        JOIN scheduler_jobs j ON rl.job_id = j.job_id
        WHERE j.group_id IN
        <foreach collection="groupIds" item="gid" open="(" separator="," close=")">
            #{gid}
        </foreach>
        <if test="jobId != null and jobId != ''">
            AND rl.job_id = #{jobId}
        </if>
        <if test="systemId != null and systemId != ''">
            AND rl.system_id = #{systemId}
        </if>
        <if test="operation != null and operation != ''">
            AND rl.operation = #{operation}
        </if>
        <if test="status != null and status != ''">
            AND rl.status = #{status}
        </if>
        <if test="reqStartDateFrom != null">
            AND rl.scheduled_time &gt;= #{reqStartDateFrom}
        </if>
        <if test="reqStartDateTo != null">
            AND rl.scheduled_time &lt;= #{reqStartDateTo}
        </if>
        ORDER BY rl.log_id DESC
        LIMIT #{limit} OFFSET #{offset}
    </select>

    <!-- Count Logs by Filters and Group IDs -->
    <select id="countByFiltersAndGroupIds" resultType="long">
        SELECT COUNT(*)
        FROM scheduler_job_run_logs rl
        JOIN scheduler_jobs j ON rl.job_id = j.job_id
        WHERE j.group_id IN
        <foreach collection="groupIds" item="gid" open="(" separator="," close=")">
            #{gid}
        </foreach>
        <if test="jobId != null and jobId != ''">
            AND rl.job_id = #{jobId}
        </if>
        <if test="systemId != null and systemId != ''">
            AND rl.system_id = #{systemId}
        </if>
        <if test="operation != null and operation != ''">
            AND rl.operation = #{operation}
        </if>
        <if test="status != null and status != ''">
            AND rl.status = #{status}
        </if>
        <if test="reqStartDateFrom != null">
            AND rl.scheduled_time &gt;= #{reqStartDateFrom}
        </if>
        <if test="reqStartDateTo != null">
            AND rl.scheduled_time &lt;= #{reqStartDateTo}
        </if>
    </select>

    <!-- Count by Job ID and Status -->
    <select id="countByJobIdAndStatus" resultType="long">
        SELECT COUNT(*)
        FROM scheduler_job_run_logs
        WHERE job_id = #{jobId} AND status = #{status}
    </select>

    <!-- Insert Log -->
    <insert id="insert" useGeneratedKeys="true" keyProperty="logId">
        INSERT INTO scheduler_job_run_logs (
            job_id, job_name, system_id, system_name, group_id, group_name,
            task_id, batch_type, operation, status, output, error, error_no, duration,
            start_time, end_time, scheduled_time, retry_attempt, workflow_run_id, workflow_priority, frst_reg_date, user_name
        ) VALUES (
            #{jobId}, #{jobName}, #{systemId}, #{systemName}, #{groupId}, #{groupName},
            #{celeryTaskName}, #{batchType}, #{operation}, #{status}, #{output}, #{errors}, #{errorNo}, #{runDuration},
            #{actualStartDate}, #{actualEndDate}, #{reqStartDate}, #{retryCount}, #{workflowRunId}, #{workflowPriority}, #{reqStartDate}, #{userName}
        )
    </insert>

    <!-- Update Status -->
    <update id="updateStatus">
        UPDATE scheduler_job_run_logs
        SET status = #{status},
            operation = #{operation}
            <if test="actualStartDate != null">, start_time = #{actualStartDate}</if>
            <if test="actualEndDate != null">, end_time = #{actualEndDate}</if>
            <if test="runDuration != null">, duration = #{runDuration}</if>
            <if test="errors != null">, error = #{errors}</if>
            <if test="errorNo != null">, error_no = #{errorNo}</if>
            <if test="output != null">, output = #{output}</if>
        WHERE log_id = #{logId}
    </update>

    <!-- Update Status with Job Name (for retry labeling) -->
    <update id="updateStatusWithJobName">
        UPDATE scheduler_job_run_logs
        SET job_name = #{jobName},
            status = #{status},
            operation = #{operation}
            <if test="actualStartDate != null">, start_time = #{actualStartDate}</if>
            <if test="actualEndDate != null">, end_time = #{actualEndDate}</if>
            <if test="runDuration != null">, duration = #{runDuration}</if>
            <if test="errors != null">, error = #{errors}</if>
            <if test="errorNo != null">, error_no = #{errorNo}</if>
            <if test="output != null">, output = #{output}</if>
        WHERE log_id = #{logId}
    </update>

    <!-- Update Status with Retry Attempt (keeps job_name unchanged) -->
    <update id="updateRetryStatus">
        UPDATE scheduler_job_run_logs
        SET status = #{status},
            operation = #{operation},
            retry_attempt = #{retryAttempt}
            <if test="actualStartDate != null">, start_time = #{actualStartDate}</if>
            <if test="actualEndDate != null">, end_time = #{actualEndDate}</if>
            <if test="runDuration != null">, duration = #{runDuration}</if>
            <if test="errors != null">, error = #{errors}</if>
            <if test="errorNo != null">, error_no = #{errorNo}</if>
            <if test="output != null">, output = #{output}</if>
        WHERE log_id = #{logId}
    </update>

    <!-- Delete Log -->
    <delete id="delete">
        DELETE FROM scheduler_job_run_logs WHERE log_id = #{logId}
    </delete>

    <!-- Delete Logs by Job ID -->
    <delete id="deleteByJobId">
        DELETE FROM scheduler_job_run_logs WHERE job_id = #{jobId}
    </delete>

    <!-- Find job IDs of orphaned logs before marking them -->
    <select id="findOrphanedJobIds" resultType="string">
        SELECT DISTINCT job_id
        FROM scheduler_job_run_logs
        WHERE status IN ('RUNNING', 'WAITING')
          AND start_time &lt; #{endDate}
          AND start_time IS NOT NULL
    </select>

    <!-- Mark orphaned logs as BROKEN on server startup -->
    <update id="markOrphanedLogsAsBroken">
        UPDATE scheduler_job_run_logs
        SET status = 'BROKEN',
            operation = 'COMPLETED',
            end_time = EXTRACT(EPOCH FROM NOW()) * 1000,
            error = 'Job orphaned: exceeded timeout threshold'
        WHERE status IN ('RUNNING', 'WAITING')
          AND start_time &lt; #{endDate}
          AND start_time IS NOT NULL
    </update>

    <!-- Mark RUNNING jobs as BROKEN when agent goes offline -->
    <update id="markRunningJobsAsBrokenBySystemId">
        UPDATE scheduler_job_run_logs
        SET status = 'BROKEN',
            operation = 'BROKEN',
            end_time = #{endDate},
            error = #{errors}
        WHERE system_id = #{systemId}
          AND status IN ('RUNNING', 'PENDING')
    </update>

    <!-- Select by Task ID for real-time log streaming -->
    <select id="selectByTaskId" resultMap="JobRunLogResultMap">
        SELECT <include refid="BaseColumns"/>
        FROM scheduler_job_run_logs
        WHERE task_id = #{taskId}
        ORDER BY log_id DESC
        LIMIT 1
    </select>

    <!-- Count recent agent-related failures for a specific server -->
    <!-- Only counts failures after last_deploy_time (if exists), otherwise after sinceTimestamp -->
    <select id="countRecentAgentFailuresBySystemId" resultType="int">
        SELECT COUNT(*)
        FROM scheduler_job_run_logs l
        LEFT JOIN scheduler_job_servers s ON l.system_id = s.system_id
        WHERE l.system_id = #{systemId}
          AND l.status = 'BROKEN'
          AND (l.error LIKE '%heartbeat%' OR l.error LIKE '%agent%' OR l.error LIKE '%connection%')
          AND l.end_time >= COALESCE(s.last_deploy_time, #{sinceTimestamp})
    </select>

    <!-- Find most recent agent-related failure timestamp for a specific server -->
    <!-- Only considers failures after last_deploy_time (if exists) -->
    <select id="findLatestAgentFailureTimeBySystemId" resultType="long">
        SELECT MAX(l.end_time)
        FROM scheduler_job_run_logs l
        LEFT JOIN scheduler_job_servers s ON l.system_id = s.system_id
        WHERE l.system_id = #{systemId}
          AND l.status = 'BROKEN'
          AND (l.error LIKE '%heartbeat%' OR l.error LIKE '%agent%' OR l.error LIKE '%connection%')
          AND (s.last_deploy_time IS NULL OR l.end_time >= s.last_deploy_time)
    </select>

    <!-- [P1] Batch: count recent agent failures for multiple servers -->
    <select id="batchCountRecentAgentFailures" resultType="map">
        SELECT l.system_id as system_id, COUNT(*) as failure_count
        FROM scheduler_job_run_logs l
        LEFT JOIN scheduler_job_servers s ON l.system_id = s.system_id
        WHERE l.system_id IN
        <foreach collection="systemIds" item="sid" open="(" separator="," close=")">
            #{sid}
        </foreach>
          AND l.status = 'BROKEN'
          AND (l.error LIKE '%heartbeat%' OR l.error LIKE '%agent%' OR l.error LIKE '%connection%')
          AND l.end_time >= COALESCE(s.last_deploy_time, #{sinceTimestamp})
        GROUP BY l.system_id
    </select>

    <!-- [P1] Batch: find latest agent failure time for multiple servers -->
    <select id="batchFindLatestAgentFailureTime" resultType="map">
        SELECT l.system_id as system_id, MAX(l.end_time) as last_failure_time
        FROM scheduler_job_run_logs l
        LEFT JOIN scheduler_job_servers s ON l.system_id = s.system_id
        WHERE l.system_id IN
        <foreach collection="systemIds" item="sid" open="(" separator="," close=")">
            #{sid}
        </foreach>
          AND l.status = 'BROKEN'
          AND (l.error LIKE '%heartbeat%' OR l.error LIKE '%agent%' OR l.error LIKE '%connection%')
          AND (s.last_deploy_time IS NULL OR l.end_time >= s.last_deploy_time)
        GROUP BY l.system_id
    </select>

    <!-- Dashboard: aggregate by day -->
    <select id="aggregateByDay" resultType="map">
        SELECT
            TO_CHAR(TO_TIMESTAMP(scheduled_time / 1000) AT TIME ZONE 'Asia/Seoul', 'MM/DD') AS day,
            COUNT(*) AS total,
            COUNT(CASE WHEN status IN ('SUCCESS', 'COMPLETED') THEN 1 END) AS success,
            COUNT(CASE WHEN status IN ('FAILED', 'FAILURE', 'BROKEN', 'TIMEOUT') THEN 1 END) AS failed
        FROM scheduler_job_run_logs
        WHERE scheduled_time >= #{from} AND scheduled_time &lt;= #{to}
        GROUP BY TO_CHAR(TO_TIMESTAMP(scheduled_time / 1000) AT TIME ZONE 'Asia/Seoul', 'MM/DD'),
                 DATE_TRUNC('day', TO_TIMESTAMP(scheduled_time / 1000) AT TIME ZONE 'Asia/Seoul')
        ORDER BY DATE_TRUNC('day', TO_TIMESTAMP(scheduled_time / 1000) AT TIME ZONE 'Asia/Seoul')
    </select>

    <!-- Dashboard: aggregate by hour for a given day -->
    <select id="aggregateByHour" resultType="map">
        SELECT
            EXTRACT(HOUR FROM TO_TIMESTAMP(scheduled_time / 1000) AT TIME ZONE 'Asia/Seoul')::int AS hour,
            COUNT(*) AS total,
            COUNT(CASE WHEN status IN ('SUCCESS', 'COMPLETED') THEN 1 END) AS success,
            COUNT(CASE WHEN status IN ('FAILED', 'FAILURE', 'BROKEN', 'TIMEOUT') THEN 1 END) AS failed
        FROM scheduler_job_run_logs
        WHERE scheduled_time >= #{dayStart} AND scheduled_time &lt;= #{dayEnd}
        GROUP BY EXTRACT(HOUR FROM TO_TIMESTAMP(scheduled_time / 1000) AT TIME ZONE 'Asia/Seoul')
        ORDER BY hour
    </select>

    <!-- Dashboard: recent logs by statuses -->
    <select id="findRecentByStatuses" resultMap="JobRunLogResultMap">
        SELECT <include refid="BaseColumns"/>
        FROM scheduler_job_run_logs
        WHERE status IN
        <foreach collection="statuses" item="s" open="(" separator="," close=")">
            #{s}
        </foreach>
          AND scheduled_time >= #{from} AND scheduled_time &lt;= #{to}
        ORDER BY log_id DESC
        LIMIT #{limit}
    </select>

    <!-- Dashboard: status distribution -->
    <select id="aggregateByStatus" resultType="map">
        SELECT status, COUNT(*) AS count
        FROM scheduler_job_run_logs
        WHERE scheduled_time >= #{from} AND scheduled_time &lt;= #{to}
        GROUP BY status
    </select>

</mapper>
